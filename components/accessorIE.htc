<public:component>
    <script type="text/javascript" id="script">
        var hasOwnProperty = {}.hasOwnProperty,
            descriptors = {},
            unshadowedProperties = {},
            elements = {},
            pageGlobal,
            behaviorGlobal = (function () { return this; }()), // DispHTCDefaultDispatch
            obj = element,
            document = behaviorGlobal.document,
            Array,
            Object,
            script = document.getElementById("script"),
            container = script.parentNode,
            transport,
            transportName = "__transport__",
            prototype = null,
            nextID = 0;

        transport = {
            defineProperty: function (name, descriptor) {
                var element,
                    attribute,
                    id = "id_" + nextID;

                if (descriptors[name]) {
                    // May have changed type from property <-> method
                    unbindProperty(name);

                    // Data descriptor
                    if (hasOwnProperty.call(descriptor, "value")) {
                        delete descriptors[name].get;
                        delete descriptors[name].set;
                        descriptors[name].value = descriptor.value;
                        if (hasOwnProperty.call(descriptor, "writable")) {
                            descriptors[name].writable = descriptor.writable;
                        }
                    // Accessor descriptor
                    } else {
                        if (hasOwnProperty.call(descriptor, "get")) {
                            descriptors[name].get = descriptor.get;
                        }
                        if (hasOwnProperty.call(descriptor, "set")) {
                            descriptors[name].set = descriptor.set;
                        }
                        delete descriptors[name].value;
                        delete descriptors[name].writable;
                    }

                    if (hasOwnProperty.call(descriptor, "configurable")) {
                        descriptors[name].configurable = descriptor.configurable;
                    }
                    if (hasOwnProperty.call(descriptor, "enumerable")) {
                        descriptors[name].enumerable = descriptor.enumerable;
                    }
                } else {
                    descriptors[name] = descriptor;
                }

                if ((descriptor.value && typeof descriptor.value === "function") || descriptor.method) {
                    //element = document.createElement("<public:method name='" + name + "' internalName='" + id + "' />");

                    //eval(id + " = function () { return methodfy(get('" + name + "')).apply(this, arguments); };");

                    obj[name] = function () { return methodfy(get(name)).apply(this, arguments); };
                } else {
                    element = document.createElement("<public:property name='" + name + "' get='get_" + id + "' put='set_" + id + "' />");

                    eval("get_" + id + " = function () { return get('" + name + "'); }; set_" + id + " = function (value) { set('" + name + "', value); };");

                    nextID += 1;

                    elements[name] = element;

                    container.insertBefore(element, script);
                }
            },

            deleteProperty: function (name) {
                unbindProperty(name);
                delete descriptors[name];
            },

            init: function (scope) {
                pageScope = scope;
                Array = pageScope.Array;
                Object = pageScope.Object;

                return obj;
            },

            getOwnPropertyDescriptor: function (name) {
                var descriptor = descriptors[name];

                if (!descriptor && hasOwnProperty.call(obj, name)) {
                    descriptor = {
                        value: obj[name]
                    };

                    transport.defineProperty(name, descriptor);
                }

                return descriptor;
            },

            getOwnPropertyNames: function (lookup) {
                var name,
                    names = [];

                lookup = lookup || {};

                for (name in descriptors) {
                    if (hasOwnProperty.call(obj, name) && !lookup[name]) {
                        names.push(name);
                        lookup[name] = true;
                    }
                }

                return names;
            }
        };

        element[transportName] = transport;

        transport.defineProperty("__proto__", {
            get: function () {
                return prototype;
            },
            set: function (value) {
                deleteUnshadowedProperties();

                prototype = value;

                if (value !== null) {
                    copyUnshadowedProperties(prototype);
                }
            }
        });

        /*obj.attachEvent("onpropertychange", function (evt) {
            var name = evt.propertyName;

            alert(name);
        });*/

        /*var silenceSets = false;

        function silentSet(name, value) {
            silenceSets = true;

            obj[name] = value;

            silenceSets = false;
        }*/

        function get(name) {
            return readDescriptor(descriptors[name]);
        }

        function set(name, value) {
            /*if (silenceSets) {
                return;
            }*/

            writeDescriptor(descriptors[name], value);
        }

        function methodfy(fn) {
            if (fn === Array.prototype.push) {
                return function () {
                    var index,
                        length = arguments.length,
                        arrayLength = this.length || 0;

                    for (index = 0; index < length; index += 1) {
                        this[arrayLength] = arguments[index];
                        arrayLength += 1;
                    }

                    this.length = arrayLength;
                };
            }
            if (fn === Array.prototype.pop) {
                return function () {
                    var arrayLength = this.length || 0;

                    if (arrayLength > 0) {
                        try {
                            delete this[arrayLength];
                        } catch (error) {
                            this[arrayLength] = undefined;
                        }

                        this.length = arrayLength - 1;
                    }
                };
            }

            return fn;
        }

        function readDescriptor(descriptor) {
            if (hasOwnProperty.call(descriptor, "value")) {
                return descriptor.value;
            } else {
                return descriptor.get.call(obj);
            }
        }

        function writeDescriptor(descriptor, value) {
            if (hasOwnProperty.call(descriptor, "value")) {
                descriptor.value = value;
            } else {
                descriptor.set.call(obj, value);
            }
        }

        function copyUnshadowedProperties(prototype) {
            var name,
                descriptor,
                index,
                name,
                names = Object.getOwnPropertyNames(prototype);

            for (index = 0; index < names.length; index += 1) {
                name = names[index];

                // Determine whether we are not shadowing the property, so we should inherit it
                if (!transport.getOwnPropertyDescriptor(name)) {
                    unshadowedProperties[name] = true;

                    transport.defineProperty(name, (function (name) {
                        return prototype[transportName] ?
                            prototype[transportName].getOwnPropertyDescriptor(name) : {
                                value: prototype[name]
                            };
                    }(name)));
                }
            }
        }

        function deleteUnshadowedProperties() {
            var name;

            for (name in unshadowedProperties) {
                transport.deleteProperty(name);
            }

            unshadowedProperties = {};
        }

        function unbindProperty(name) {
            if (elements[name]) {
                container.removeChild(elements[name]);
                delete elements[name];
            }
        }
    </script>
</public:component>
